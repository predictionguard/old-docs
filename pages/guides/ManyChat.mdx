---
title: ManyChat Example
---

# Using Prediction Guard to provide responses in ManyChat

Manychat is a popular chat automation tool for customer service. In this example we will go through two options for how to implement LLM responses using the Prediction Guard API. One being a very simple single question without any context that can be setup within 5-10 minutes without any manual coding. The second option involves setting up a lambda function (or any other alternative) to process the entire chat request, send a request to Prediction Guard, and return a response to manychat using their [dynamic block](https://manychat.github.io/dynamic_block_docs/channels/). It is possible to do context within manychat exclusively but this takes a lot of manual work within manychat.

## Prerequisites:

Prediction Guard API Key

[Sign-up for Manychat](https://manychat.com/signup) (must be a premium account)

[Create two Manychat User Custom fields](https://support.manychat.com/support/solutions/articles/36000003046-user-input-and-custom-fields#:~:text=Custom%20Fields%20allow%20you%20to,to%20create%20and%20manage%20them.) (User_Question1,Bot_Response1)

[Create a telegram bot](https://support.manychat.com/support/solutions/articles/36000329373-getting-started-how-to-create-a-telegram-bot-in-manychat)

## No context example:

Our goal in this example is to allow the customer to click a button if they need a question answered. This will send a request to the Prediction Guard Chat API endpoint and the response from the API will be sent to the customer as a Telegram message. They can then choose to ask a new question, speak to an agent, or close the conversation.

1.  Create a new automation
2.  Select a context to trigger the automation
3.  Create a Telegram Menu via a telegram send message block. This would normally be your general welcome message and a preselected couple of buttons. We are going to send the user's question to Prediction Guard when the user selects the “Question?” button.


4.  Add another telegram message block but this time select User Input. Link it to the “Question?” button.
5.  Add a prompt for the user to input their question in the text box
6.  Save response to a custom user field (for example User_Question1)



7.  Add a “Make External Request Action Block”
8.  Add a Clear User Field for Bot_Response1 (this should be above the External Request Action)
9.  Fill out the HTTP Post request. You can use the cURL chat example in our chat [documentation](https://docs.predictionguard.com/reference/chat).

10. Add Request URL: [https://api.predictionguard.com/chat](https://api.predictionguard.com/chat)
11. Add Headers:

Content-Type: application/json

X-api-key: <YOUR PG API KEY HERE>



3.  Fill out the body of the request:

Your body should look like this (make sure to replace the field below by clicking add a field and using the User_Question1 custom user field):

```bash {

 "model": "Neural-Chat-7B",

 "messages": [

 {

 "role": "system",

 "content": "You are a helpful bot for a company called prediction guard."

 },

 {

 "role": "user",

 "content": "<YOUR USER QUESTION PLACEHOLDER>"

 }

 ]

 }
```

10. Test the response.

11. Map the response JSONPath to the Bot_Response1 custom field you made before starting the guide. (The JSON path should be something like this : $.choices[0].message.content)



12. Create a new Telegram Message Block and link it as the next step from the Make External Request Action we just made.

13. The message should output the Bot_Response1 custom user field.

14. Create a Telegram Menu within the same block and make sure there is a button that allows them to ask a new question. If they click that button it should route them back to the block we created in steps 4-6. There should also be two other buttons: Talk to an agent and Close the Conversation or some other button to close the loop.

If you followed these steps your automation should look something like this at the end:



Your telegram chat should look like this after a question is answered:



## Include Conversation Context Example:

Prerequisites:

- Your Prediction Guard API Key

- [Sign-up for Manychat](https://manychat.com/signup) (must be a premium account)

- [Create two Manychat User Custom fields](https://support.manychat.com/support/solutions/articles/36000003046-user-input-and-custom-fields#:~:text=Custom%20Fields%20allow%20you%20to,to%20create%20and%20manage%20them.) (User_Text, Bot_Text)

- [Create a telegram bot](https://support.manychat.com/support/solutions/articles/36000329373-getting-started-how-to-create-a-telegram-bot-in-manychat)

- AWS Lambda Function that can be reached by the Internet

Our goal in this example is to allow the customer to click a button if they need a question answered. However, notably this will include the context of the previous questions. This will send a request to your personal Lambda function url that processes the ManyChat input, makes an API request to PredictionGuard, and formats the response for ManyChat. The ManyChat response will send the message to the customer and also replace/create the context fields in manychat you have created. They can then choose to continue that conversation, ask a new question (which will clear the context fields), speak to an agent, or close the conversation.

1.  Follow steps 1-6 in the basic example.
2.  Instead of making an External Request Action Block we are actually going to add a “Get Dynamic Content”.



3.  In this dynamic block we are going to send our Users Full Contact Data to our [Lambda function url](https://docs.aws.amazon.com/lambda/latest/dg/lambda-urls.html).



4.  Build your Lambda function. We have these goals:

- Parse Incoming Request.

- Extract Custom Fields.

- Extract Conversation History which we will save to the User_Text, Bot_Text custom TEXT customer fields [you should have made](https://support.manychat.com/support/solutions/articles/36000003046-user-input-and-custom-fields). We will not be using an array type due to current limitations at the time of creating this article. However, these should be stored in an array type format so you can programmatically build the [Prediction Guard API chat request](https://docs.predictionguard.com/reference/chat).

- Append the last customer input to the user messages array (User_Text)

- Prepare Messages for API Request by formatting a request in the format required by the [Prediction Guard API](https://docs.predictionguard.com/reference/chat)

- Make API Request to Prediction Guard and Process Response

- Append the prediction guard reply to the bot messages array (Bot_Text)

- Format ManyChat Response (it must be formatted as noted in this [doc](https://manychat.github.io/dynamic_block_docs/channels/), please make sure to note what platform you are using) This will respond to the user and also save over the new User_Text, Bot_Text with the new complete context.

- Handle Errors

Here is a Javascript example you can use:

    ```Javascript const https = require('https');

    exports.handler = async (event) => {
        // Parse the incoming ManyChat request
        const requestBody = JSON.parse(event.body);
        const customFields = requestBody.custom_fields;

        // Extract the latest user question and conversation history
        const lastUserInput = customFields.convo_placeholder;
        const userArrayString = customFields.User_Text || JSON.stringify([]);
        const botArrayString = customFields.Bot_Text || JSON.stringify([]);

        const userArray = JSON.parse(userArrayString);
        const botArray = JSON.parse(botArrayString);

        // Append the latest user input to the user array
        userArray.push(lastUserInput);

        // Prepare the messages array for the PredictionGuard API request
        let messages = [
            {
                role: "system",
                content: "You are a helpful assistant for a toy Company named Walt's Toys. Welcome the customer and only talk about toys!"
            },
            // Interleave user and bot messages
            ...userArray.map((content, i) => [{ role: "user", content }, { role: "assistant", content: botArray[i] }])
                       .flat()
                       .filter(msg => msg.content) // Filter out undefined content
        ];

        const apiData = JSON.stringify({ model: "Neural-Chat-7B", messages });

        const options = {
            hostname: 'api.predictionguard.com',
            path: '/chat',
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': '<YOUR PREDICTION GUARD API KEY>' // Replace with your actual API key
            }
        };

        // Function to make the API request
        const makeApiRequest = () => {
            return new Promise((resolve, reject) => {
                const req = https.request(options, (res) => {
                    let responseString = '';

                    res.on('data', (chunk) => {
                        responseString += chunk;
                    });

                    res.on('end', () => {
                        try {
                            const response = JSON.parse(responseString);
                            if (!response.choices || response.choices.length === 0) {
                                throw new Error('Invalid response: choices array is missing or empty.');
                            }
                            resolve(response);
                        } catch (error) {
                            reject(error);
                        }
                    });
                });

                req.on('error', (error) => {
                    reject(error);
                });

                req.write(apiData);
                req.end();
            });
        };

        try {
            const apiResponse = await makeApiRequest();
            const replyMessage = apiResponse.choices[0].message.content;

            // Append the API response to the bot array
            botArray.push(replyMessage);

            // Format the response for ManyChat
            const manyChatResponse = {
                version: "v2",
                content: {
                    type: "telegram", // Adjust as needed
                    messages: [{
                        type: "text",
                        text: replyMessage
                    }],
                    actions: [
                        {
                            action: "set_field_value",
                            field_name: "User_Text",
                            value: JSON.stringify(userArray)
                        },
                        {
                            action: "set_field_value",
                            field_name: "Bot_Text",
                            value: JSON.stringify(botArray)
                        }
                    ],
                    quick_replies: [] // Adjust as needed
                }
            };

            return {
                statusCode: 200,
                body: JSON.stringify(manyChatResponse),
                headers: { 'Content-Type': 'application/json' }
            };
        } catch (error) {
            return {
                statusCode: 500,
                body: JSON.stringify({ message: error.message }),
                headers: { 'Content-Type': 'application/json' }
            };
        }
    };

```
Your response to Manychat for telegram should look something like this:
```bash
    {"version":"v2","content":{"type":"telegram","messages":[{"type":"text","text":"I'm still doing great, and I'm ready to help you find the perfect toy for your little one. Let me know if you need any recommendations or have any questions. We have a lot of fun toys to explore together!"}],"actions":[{"action":"set_field_value","field_name":"User_Text","value":"[\"How is your day?\",\"How is your day?\"]"},{"action":"set_field_value","field_name":"Bot_Text","value":"[\"Hello there! I'm doing great, as I'm always excited to talk about toys. How about you? Are you looking for any specific toys or just browsing? We have a wide variety of options for you to choose from.\",\"I'm still doing great, and I'm ready to help you find the perfect toy for your little one. Let me know if you need any recommendations or have any questions. We have a lot of fun toys to explore together!\"]"}],"quick_replies":[]}}
```

5. Your flow should now look like this:



- The customer should be able to continue the conversation. This should just route back to the dynamic request without clearing the user fields.
- The customer should also be able to ask a new question which should clear the user fields. This will clear the context of the conversation.
- Finally it is best to provide a way for a person to reach a real human agent and close the ticket if they so desire
```
