---
title: LangChain LLM Wrapper
---

# Using Prediction Guard proxies in LangChain (as an LLM)

[LangChain](https://github.com/hwchase17/langchain) is one of the most popular AI projects, and for good reason! LangChain
helps you "Build applications with LLMs through composability." LangChain doesn't solve the problems of model 
reliability, use case/ domain configuration, or future proofing that are addressed by Prediction Guard. Therefore, combining 
the two (Prediction Guard + LangChain) gives you **a framework for developing reliable, future proofed applications powered 
by language models.**

## Prediction Guard LLM Wrapper

You can use any Prediction Guard `text-gen` proxy as an LLM in LangChain (including the `default-text-gen` proxy). To do
this currently you need to define an LLM "wrapper" class in Python. We have a 
[PR open with LangChain](https://github.com/hwchase17/langchain/pull/3370) that will hopefully make this much more seamless,
but it's pretty easy even without that. 

Just define the following class in your Python code:

```python copy
from pydantic import Extra, root_validator
from typing import Any, Dict, List, Optional

import predictionguard as pg
from langchain.llms.base import LLM
from langchain.utils import get_from_dict_or_env
from langchain.llms.utils import enforce_stop_tokens

# LangChain model class
class PredictionGuard(LLM):
    """Wrapper around Prediction Guard large language models.
    To use, you should have the ``predictionguard`` python package installed, and the
    environment variable ``PREDICTIONGUARD_TOKEN`` set with your access token, or pass
    it as a named parameter to the constructor.
    Example:
        .. code-block:: python
            pgllm = PredictionGuard(name="text-gen-proxy-name", token="my-access-token")
    """

    client: Any  #: :meta private:
    name: Optional[str] = "default-text-gen"
    """Proxy name to use."""

    max_tokens: int = 256
    """Denotes the number of tokens to predict per generation."""

    temperature: float = 0.75
    """A non-negative float that tunes the degree of randomness in generation."""

    token: Optional[str] = None

    stop: Optional[List[str]] = None

    class Config:
        """Configuration for this pydantic object."""

        extra = Extra.forbid

    @root_validator()
    def validate_environment(cls, values: Dict) -> Dict:
        """Validate that the access token and python package exists in environment."""
        token = get_from_dict_or_env(
            values, "token", "PREDICTIONGUARD_TOKEN"
        )
        try:
            import predictionguard as pg

            values["client"] = pg.Client(token=token)
        except ImportError:
            raise ValueError(
                "Could not import predictionguard python package. "
                "Please install it with `pip install predictionguard`."
            )
        return values

    @property
    def _default_params(self) -> Dict[str, Any]:
        """Get the default parameters for calling Cohere API."""
        return {
            "max_tokens": self.max_tokens,
            "temperature": self.temperature,
        }

    @property
    def _identifying_params(self) -> Dict[str, Any]:
        """Get the identifying parameters."""
        return {**{"name": self.name}, **self._default_params}

    @property
    def _llm_type(self) -> str:
        """Return type of llm."""
        return "predictionguard"

    def _call(self, prompt: str, stop: Optional[List[str]] = None) -> str:
        """Call out to Prediction Guard's model proxy.
        Args:
            prompt: The prompt to pass into the model.
        Returns:
            The string generated by the model.
        Example:
            .. code-block:: python
                response = pgllm("Tell me a joke.")
        """
        params = self._default_params
        if self.stop is not None and stop is not None:
            raise ValueError("`stop` found in both the input and default params.")
        elif self.stop is not None:
            params["stop_sequences"] = self.stop
        else:
            params["stop_sequences"] = stop

        response = self.client.predict(name=self.name, data={
            "prompt": prompt,
            "max_tokens": params["max_tokens"],
            "temperature": params["temperature"]
        })
        text = response["text"]

        # If stop tokens are provided, Prediction Guard's endpoint returns them.
        # In order to make this consistent with other endpoints, we strip them.
        if stop is not None or self.stop is not None:
            text = enforce_stop_tokens(text, params["stop_sequences"])

        return text
```

## Basic LLM usage

To use the Prediction Guard [default `text-gen` proxy](../defaults) as an LLM:

```python copy
pgllm = PredictionGuard(name="default-text-gen", token="<your access token>")
pgllm("Tell me a joke")
```

import { Callout } from 'nextra-theme-docs'

<Callout type="info" emoji="ℹ️">
  If you prefer, you can define your access token via the environmental variable `PREDICTIONGUARD_TOKEN` and remove the `token` argument. 
</Callout>

This should return something like:

```
\n\nQ: What did the fish say when he hit the wall? \nA: Dam!
```

## Chaining

Now to use a Prediction Guard proxy as the LLM in a chaining operation, just supply the initialized LLM object to 
LangChain as follows:

```python copy
from langchain import PromptTemplate, LLMChain

template = """Question: {question}

Answer: Let's think step by step."""
prompt = PromptTemplate(template=template, input_variables=["question"])
llm_chain = LLMChain(prompt=prompt, llm=pgllm, verbose=True)

question = "What NFL team won the Super Bowl in the year Justin Beiber was born?"

llm_chain.predict(question=question)
```

This should return something like:

```
> Entering new LLMChain chain...
Prompt after formatting:
Question: What NFL team won the Super Bowl in the year Justin Beiber was born?

Answer: Let's think step by step.

> Finished chain.
 Justin Bieber was born in 1994, so the NFL team that won the Super Bowl in 1994 was the Dallas Cowboys.
```
